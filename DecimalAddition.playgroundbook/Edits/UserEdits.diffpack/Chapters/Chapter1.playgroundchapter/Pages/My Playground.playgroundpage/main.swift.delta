<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>Diff</key>
	<array>
		<dict>
			<key>ModifiedContent</key>
			<string>/*
 This project gets two distinct strings as numbers and adds two numbers into a string text using multiple functions.
 With this simple calculator you can add extremely long numbers without any number loss.
 Created in 23, April, 2022 in iPad Playground application
 Author: Manoochehr Ebrahimian
 --------------------------------
 Examples of using the class with and without initializers
 1 - without initializer
 let add = DecimalAddition()
 add.AddTwoStringsAsNumbers_Comprehensive(adding: "123.6", to: "97.48")
 2 - with an initializer
 let add2: String = DecimalAddition(firstNumber: "12.1", secondNumber: "45").result
 */
class DecimalAddition {
    var result : String = "0"
    init (firstNumber:String, secondNumber:String) {
        result = AddTwoStringsAsNumbers_Comprehensive(adding: firstNumber, to: secondNumber)
    }
    init () {
        
    }
func AddTwoStringsAsNumbers(add firstNumber: String, to secondNumber: String, hasTransferPart : Bool = false) -&gt; String {
    let firstNumberLength = firstNumber.count
    let secondNumberLength = secondNumber.count
    //Declaring the number which is larger in digits
    var largerNumber = (firstNumberLength &gt; secondNumberLength) ? firstNumber : secondNumber
    var smallerNumber =  (firstNumberLength &lt;= secondNumberLength) ? firstNumber : secondNumber
    //Adding zeros at the beginning of smaller number in order to have two equal numbers in length using Function DigitEqualizer
    smallerNumber = DigitEqualizer(add: largerNumber.count - smallerNumber.count, to: smallerNumber)
    //the process of adding begins here
    var finalStringSum: String = ""
    var transferringNumber:Int = hasTransferPart ? 1 : 0
        // creating a for loop with largerNumber's length
    for index in (0...largerNumber.count-1).reversed() {
        //getting the last digits of each numbers
        let firstDigit = Array(largerNumber)[index]
        let secondDigit = Array(smallerNumber)[index]
        //summing the numbers as circulating numbers
        let circulatingNumber = AddTwoStringDigits(add: firstDigit, to: secondDigit, plus: transferringNumber)
        //adding the new digit before older digits
        finalStringSum = circulatingNumber.ones.lowercased() + finalStringSum
        transferringNumber = Int(circulatingNumber.tens.lowercased()) ?? 0
    }
    //Adding extra digit at the beginning of the final number if exists!
    if (transferringNumber != 0) {
        finalStringSum = String(transferringNumber) + finalStringSum
    }
    
    return finalStringSum
}
func DigitEqualizer(add Zeros:Int, to number:String) -&gt;String {
    var addingZeros : String = ""
    if Zeros != 0 {
    for index in 1...Zeros {
        addingZeros += "0" 
    }}
    return addingZeros + number
}
func AddTwoStringDigits(add firstDigit: Character, to secondDigit: Character, plus tranferringNumber:Int = 0) -&gt; (ones: Character, tens: Character) {
    let numberOne = firstDigit.wholeNumberValue ?? 0
    let numberTwo = secondDigit.wholeNumberValue ?? 0
    let sum : Int = numberOne + numberTwo + tranferringNumber
    let outputString: String = String(sum)
    var firstCharacter, secondCharacter : Character
    if outputString.count &gt; 1 {
        firstCharacter = Array(outputString)[1]
        secondCharacter = Array(outputString)[0]
    }else {
        firstCharacter = Array(outputString)[0]
        secondCharacter = "0"
    }
    return (firstCharacter, secondCharacter)
}

//This function checks whether the number has decimal part or not
func DecimalChecker(number: String) -&gt; Bool {
    return number.contains(".")
}
//This function divides the integer and decimap part of the number as two strings
func DecimalSeparator(number: String) -&gt; (integerPart: String, decimalPart:String) {
    let splittedNumber = number.split(separator: ".", maxSplits: 1, omittingEmptySubsequences: true)
    return (splittedNumber[0].lowercased(), splittedNumber[1].lowercased())
    
} 
/*This method decides the summation type
 if both numbers do not have decimal parts adds .0 at the end of them 
 */
func AddDecimalPart(number:String) -&gt; String {
    return number+".0"
}
//the main method
func AddTwoStringsAsNumbers_Comprehensive(adding firstNumber:String, to secondNumber:String) -&gt; (String) {
    let numberOne = DecimalChecker(number: firstNumber) ? firstNumber : AddDecimalPart(number: firstNumber);
    let numberTwo = DecimalChecker(number: secondNumber) ? secondNumber : AddDecimalPart(number: secondNumber)
    //Creating an instance of seperated numbers using DecimalSeparator method. this also can be used with creating structs or class:) but i utilized function. this instances will be called once and used several times in order to having a clear code :)
    let separatedNumberOne = DecimalSeparator(number: numberOne)
    let separatedNumberTwo = DecimalSeparator(number: numberTwo)
    /*
     Now, both numbers have decimal parts. 
     This snippet will be divided into three parts:
     1- adding decimal parts together
     2- adding integer parts
     3- sticking two parts and making a single number
     */
    //1-Adding Decimal parts together
    let firstDecimal = separatedNumberOne.decimalPart
    let secondDecimal = separatedNumberTwo.decimalPart
    /*
     In decimal numbers, order of adding zeros to equalize numbers differs from integer parts.
     for example 1.1 and 31.567 will be divided to:
     01 and 31 = 32 --&gt; correct
     and
     1 and 567 = 568 --&gt; wrong
     So, we need to add zeros after the smaller number.
     We can use different method; but this makes our code unclear.
     To avoid this problem we can first equalize decimal numbers in our desired order using a new function called EqualizeDecimalParts()
     */
    let equalzedDecimal = EqualizeDecimalParts(firstDecimalPart: firstDecimal, secondDecimalPart: secondDecimal)
    var decimalResult = AddTwoStringsAsNumbers(add: equalzedDecimal.firstEqualized, to: equalzedDecimal.secondEqualized)
        //checking if the result has need to transfer any number to Integer part?
    let needToTransfer : Bool = decimalResult.count &gt; equalzedDecimal.firstEqualized.count ? true : false
    decimalResult = needToTransfer ? decimalResult.suffix(decimalResult.count-1).lowercased() : decimalResult
    //2 - Adding Integer parts together
    let firstInteger = separatedNumberOne.integerPart
    let secondInteger = separatedNumberTwo.integerPart
    let integerResult = AddTwoStringsAsNumbers(add: firstInteger, to: secondInteger, hasTransferPart: needToTransfer)
    
return integerResult + "." + decimalResult
    
}

//This methods add zeros after the smaller number:)
func EqualizeDecimalParts(firstDecimalPart: String, secondDecimalPart:String) -&gt; (firstEqualized: String, secondEqualized:String) {
    let largerNumber = firstDecimalPart.count &gt; secondDecimalPart.count ? firstDecimalPart : secondDecimalPart
    var smallerNumber = firstDecimalPart.count &lt;= secondDecimalPart.count ? firstDecimalPart : secondDecimalPart
    let digitDifferences:Int = largerNumber.count - smallerNumber.count
    if digitDifferences &gt; 0 {
        var addingZeros = ""
        for index in 1...digitDifferences {
            addingZeros += "0"
        }
        smallerNumber += addingZeros
        return (largerNumber,smallerNumber)
    }else { 
        return (firstDecimalPart,secondDecimalPart)
    }
}
}
let add2: String = DecimalAddition(firstNumber: "12.169868796785878645647", secondNumber: "45.9000000000000000000000000987674567465346326342426").result
 
</string>
			<key>ModifiedRange</key>
			<string>{0, 7527}</string>
			<key>OriginalContent</key>
			<string>
</string>
			<key>OriginalRange</key>
			<string>{0, 1}</string>
		</dict>
	</array>
	<key>File</key>
	<string>Chapters/Chapter1.playgroundchapter/Pages/My Playground.playgroundpage/main.swift</string>
</dict>
</plist>
